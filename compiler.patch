diff --git a/reader.ml b/reader.ml
index 0955b39..f572877 100644
--- a/reader.ml
+++ b/reader.ml
@@ -1,4 +1,3 @@
-
 (* reader.ml
  * A compiler from Scheme to x86/64
  *
@@ -6,7 +5,7 @@
  *)
 
 #use "pc.ml";;
-
+open PC;;
 exception X_not_yet_implemented;;
 exception X_this_should_not_happen;;
   
@@ -49,8 +48,344 @@ let normalize_scheme_symbol str =
 	s) then str
   else Printf.sprintf "|%s|" str;;
 
-let read_sexpr string = raise X_not_yet_implemented ;;
 
-let read_sexprs string = raise X_not_yet_implemented;;
+
+let nt_Digit = one_of "0123456789";;
+(******************************** Boolean parser**********************************************************************)
+let nt_BooleanParser s = 
+  let ((a,b),c) = (not_followed_by (caten (char '#') (disj (char_ci 't') (char_ci 'f'))) nt_Digit)  s in
+  match b with 
+  | 't'-> (Bool true,c)
+  | 'T'-> (Bool true,c)
+  | 'f'-> (Bool false,c)
+  | 'F'-> (Bool false,c)
+  | _-> raise X_this_should_not_happen;;
+
+
+(******************************** Char parser**********************************************************************)
+let nt_CharPrefixParser =caten ( char '#') (char '\\') ;;
+
+let nt_VisibleSimpleChar s =let (a,s)=nt_any s in (a,s);;
+
+let nt_newline=(word_ci "newline");;
+let nt_nul=(word_ci "nul");;
+let nt_page=(word_ci "page");;
+let nt_return=(word_ci "return");;
+let nt_space=(word_ci "space");;
+let nt_tab=(word_ci "tab");;
+
+let nt_NamedChar s = 
+  let (c,s) = (disj_list [nt_newline;nt_return;nt_tab;nt_space;nt_nul;nt_page]) s in
+  match (list_to_string (List.map lowercase_ascii c)) with
+  | "newline"-> (Char.chr 10,s)
+  | "nul"-> (Char.chr 0,s)
+  | "return"-> (Char.chr 13,s)
+  | "tab"-> (Char.chr 9,s)
+  | "page"-> (Char.chr 12,s)
+  | "space"-> (Char.chr 32,s)
+  | _->raise X_this_should_not_happen;;
+
+let nt_HexCharDigit = one_of_ci "0123456789abcdefABCDEF";;
+let nt_HexChar s =
+  let((x,x1),s) =(caten(char_ci 'x')(plus nt_HexCharDigit)) s in
+    (Char.chr(int_of_string ("0x"^(list_to_string x1))),s);;
+  
+let nt_CharParser s =
+  let ((solamet, slash),s) = nt_CharPrefixParser  s in
+    let (c,s) = disj_list [nt_NamedChar; nt_HexChar ;nt_VisibleSimpleChar] s in (Char c,s);;
+
+(********************************************* Number Parser***************************************************)
+
+let nt_HexDigit=one_of "0123456789abcdefABCDEF";;
+let nt_MinusOrPlus s= (disj (char '+') (char '-')) s  ;;
+let nt_NaturalNumber=plus nt_Digit;;
+let nt_HexNumber = plus nt_HexDigit;;
+ 
+let nt_HexIntegerWithSignParser s= 
+  let ((solamet,x),s)=caten (char '#') (char_ci 'x') s in
+    let ((sign,n),s) = caten nt_MinusOrPlus nt_HexNumber s in
+      match sign with
+      | '+' -> (int_of_string ("0x"^(list_to_string(n))),s)
+      | '-' -> (int_of_string ("0x"^(list_to_string(n))) * -1,s)
+      |_->raise X_this_should_not_happen;;
+
+let nt_HexIntegerWithoutSignParser s=
+  let ((solamet ,x ) , s) = caten(char '#') (char_ci 'x') s in
+    let (n,s) = nt_HexNumber s in
+      (int_of_string ("0x"^list_to_string n),s);;
+  
+let nt_HexIntegerParser s = 
+  let (n,s) = disj nt_HexIntegerWithSignParser nt_HexIntegerWithoutSignParser s in (Int n,s);;
+
+let nt_IntegerWithSignParser s = 
+  let (sign, s) = nt_MinusOrPlus s in
+    let (n, s) = nt_NaturalNumber s in
+    match sign with
+    | '+' -> (int_of_string (list_to_string n),s)
+    | '-' -> ((int_of_string (list_to_string n)) * -1,s)
+    |_->raise X_this_should_not_happen;;
+
+let nt_IntegerWithoutSignParser s = 
+  let (n,s) = (nt_NaturalNumber s) in (int_of_string(list_to_string n),s);;
+
+let nt_IntegerParser s = 
+  let (n,s) = disj_list [nt_IntegerWithSignParser ;nt_IntegerWithoutSignParser] s in (Int n,s);;
+
+let nt_FloatWithSignParser s = 
+  let (sign, s) = nt_MinusOrPlus s in
+    let (n1,s) = nt_NaturalNumber s in
+      let (dot, s) = (char '.')s in
+        let (n2, s) = nt_NaturalNumber s in
+        match sign with
+        |'+' -> (float_of_string (list_to_string(n1@dot::n2)),s)
+        |'-' -> (float_of_string (list_to_string(n1@dot::n2)) *. -1.0,s)
+        |_->raise X_this_should_not_happen;;
+
+let nt_FloatWithoutSignParser s =
+  let (n1, s) = nt_NaturalNumber s in
+    let (dot, s) = (char '.')s in
+      let (n2, s) = nt_NaturalNumber s in
+        (float_of_string (list_to_string(n1@dot::n2)),s);;
+
+let nt_FloatParser s = 
+  let (n,s) = disj_list [nt_FloatWithSignParser ;nt_FloatWithoutSignParser] s in  (Float n,s);; 
+
+
+
+let nt_HexFloatWithSignParser s = 
+  let ((solmet, x),s)=caten(char '#')(char_ci 'x') s in
+    let ((sign,n1),s) = caten nt_MinusOrPlus nt_HexNumber s in
+      let ((dot,n2),s) = caten (char '.') nt_HexNumber s in
+        match sign with
+        |'+' -> ((float_of_string(("0x" ^ list_to_string n1) ^ "." ^(list_to_string n2))),s)
+        |'-' -> ((float_of_string(("0x" ^ list_to_string n1) ^ "." ^ (list_to_string n2))) *. -1.0,s)
+        |_ -> raise X_this_should_not_happen;;
+
+let nt_HexFloatWithoutSignParser s = 
+  let ((solmet, x),s)=caten(char '#')(char_ci 'x') s in
+    let ((n1,dot),s) = caten nt_HexNumber (char '.') s in
+      let (n2,s) = nt_HexNumber s in
+      (float_of_string(("0x" ^ list_to_string n1) ^ "." ^(list_to_string n2)),s);;
+
+let nt_HexFloatParser s = 
+  let (n,s) = disj nt_HexFloatWithSignParser nt_HexFloatWithoutSignParser s in (Float(n),s);;
+
+let nt_ExIntegerWithSignParser s = 
+  let (sign, s) = nt_MinusOrPlus s in
+    let (n, s) = nt_NaturalNumber s in
+    match sign with
+    | '+' -> (float_of_string (list_to_string n),s)
+    | '-' -> ((float_of_string (list_to_string n)) *. -1.0,s)
+    |_->raise X_this_should_not_happen;;
+
+let nt_ExIntegerWithoutSignParser s = 
+  let (n,s) = (nt_NaturalNumber s) in (float_of_string(list_to_string n),s);;
+
+let nt_ExFloatWithSignParser s = 
+  let (sign, s) = nt_MinusOrPlus s in
+    let (n1,s) = nt_NaturalNumber s in
+      let (dot, s) = (char '.')s in
+        let (n2, s) = nt_NaturalNumber s in
+        match sign with
+        |'+' -> (float_of_string (list_to_string(n1@dot::n2)),s)
+        |'-' -> (float_of_string (list_to_string(n1@dot::n2)) *. -1.0,s)
+        |_->raise X_this_should_not_happen;;
+
+let nt_ExFloatWithoutSignParser s =
+  let (n1, s) = nt_NaturalNumber s in
+    let (dot, s) = (char '.')s in
+      let (n2, s) = nt_NaturalNumber s in
+        (float_of_string (list_to_string(n1@dot::n2)),s);;
+
+let nt_Exponent s =
+  let (n1,s) = disj_list[nt_ExFloatWithSignParser ;nt_ExFloatWithoutSignParser;nt_ExIntegerWithSignParser ;nt_ExIntegerWithoutSignParser] s in
+    let (e,s) = (char_ci 'e') s in
+      let(n2,s) = disj_list[nt_ExIntegerWithSignParser ;nt_ExIntegerWithoutSignParser] s in
+        (Float(float_of_string(list_to_string((string_to_list(string_of_float n1))@'e'::(string_to_list(string_of_int (int_of_float n2)))))),s);;
+let nt_sym =disj (range_ci 'a' 'z') (one_of  "/0123456789!$^*-_=+<>?/:");;
+let nt_NumberParser s = 
+  let (n,s) = (not_followed_by (disj_list [ (nt_Exponent)  ;nt_HexFloatParser;nt_FloatParser;nt_IntegerParser;nt_HexIntegerParser]) nt_sym ) s in (Number(n),s);;
+
+(********************************************* String Parser***************************************************)
+let nt_Allchars= disj_list [(range_ci (Char.chr 0) (Char.chr 33)); (range_ci (Char.chr 35) (Char.chr 91));(range_ci (Char.chr 93) (Char.chr 127))];;
+let nt_NonQuote = disj_list [range (Char.chr 0)(Char.chr 33); range (Char.chr 35) (Char.chr 127)];;
+
+let nt_newline s = let(_,s) = (word_ci "\\n") s in ('\n',s);;
+let nt_page s = let(_,s) = (word_ci "\\f") s in ('\012',s);;
+let nt_return s = let(_,s) = (word_ci "\\r") s in ('\r',s);;
+let nt_tab s = let(_,s) = (word_ci "\\t") s in ('\t',s);;
+let nt_slash s = let(_,s) = (word_ci "\\\\") s in ('\\',s);;
+let nt_quote s = let(_,s) = (word_ci "\\\"") s in ('\"',s);;
+
+let nt_StringMetaCharParser s =  disj_list[nt_newline;nt_page;nt_return;nt_tab;nt_slash;nt_quote] s ;;
+let nt_StringLiteralCharParser s = let (c,s)= nt_Allchars s in (c,s);;
+
+let nt_StringHexCharParser s =
+  let ((slash ,x ),s) =caten (char '\\') (char_ci 'x')s in
+    let ((str,semi),s) = caten (plus nt_HexDigit) (char ';') s in
+      (Char.chr(int_of_string ("0x"^(list_to_string str))),s);;
+
+let nt_StringChar s = (disj_list[nt_StringHexCharParser; nt_StringMetaCharParser; nt_StringLiteralCharParser]) s;;
+
+let nt_StringParser s = 
+  let (quote1,s) =  (char '\"') s in
+      let (str,s) = star(nt_StringChar) s in
+        let (quote2,s)=(char '\"') s in
+        (String(list_to_string str),s);;
+
+(********************************************* symbol parser***************************************************)
+let nt_SymbolChar s = 
+  let (ch1,s) = disj (range_ci 'a' 'z') (one_of  "/0123456789!$^*-_=+<>?/:") s in
+    let ch2 = lowercase_ascii ch1 in (ch2, s);;
+
+let nt_SymbolParser s = 
+  let (sym,s) = plus nt_SymbolChar  s in
+    (Symbol(list_to_string sym),s);;
+
+
+(******************************************* whitespaces ************************************)
+
+let nt_WhitespacesParser s = let (spaces, s1)= (star nt_whitespace)  s in
+  (list_to_string s1);;
+
+(******************************************** Comment****************************************)
+let nt_EndOfLine s = let (eol,s) = (char '\n') s in ([eol],s);;
+let nt_EndOfLine_Or_EndOfInput= disj nt_end_of_input nt_EndOfLine;;
+
+let nt_NonSemicolon= disj_list [range (Char.chr 0)(Char.chr 58); range (Char.chr 60) (Char.chr 127)];;
+
+let nt_NonNL = disj_list [range (Char.chr 0)(Char.chr 9); range (Char.chr 11) (Char.chr 127)];;
+
+let nt_CommentParser s = 
+  let (coma, s )=(char ';')  s in
+    let ((comment,eol), s) = caten (star nt_NonNL) (nt_EndOfLine_Or_EndOfInput) s in
+    (' ',s);;
+
+
+(********************************************nill parser *****************************************)
+let nt_NilParser s = 
+  let ((a,b),c)=caten (char '(') (star (disj nt_CommentParser nt_whitespace))  s in
+    let (lparen,s)= (char ')')  c in
+      (Nil,s);;
+(*********************************************pair parser *****************************************)
+let nt_LeftParent s = (disj(char '(')(char '[')) s;;
+let nt_RightParent s = (disj(char ')')(char ']')) s;;
+let nt_3dots s = let(dots,s) = (word "...") s in (' ',s);;
+let nt_Dot s = (char '.') s;;
+let nt_solamet s = (char '#') s;;
+let make_enclosed l exp r = let exp = caten(caten l exp) r in pack exp (fun((l,exp),r) ->exp);;
+let nt_Nonrightparent = disj_list [range (Char.chr 0)(Char.chr 40); range (Char.chr 42) (Char.chr 127)];;
+
+
+let rec nt_Sexpr s  =
+  let (spaces,s) = star (disj nt_whitespace nt_CommentParser) s in 
+    (disj_list[nt_SexprComment; nt_Unqouted;nt_UnquotedSpliced;nt_QQouted;nt_Quoted;nt_VectorParser;nt_SexpDottedList;nt_SexpList;nt_VectorParserBracket;nt_SexpDottedListBracket;nt_SexpListBracket;nt_Ellipsis;nt_BooleanParser; nt_StringParser; nt_CharParser; nt_NumberParser;nt_SymbolParser]) s and
+
+nt_SexpList s=
+  let (exp,s) = (make_enclosed (char '(') (star nt_Sexpr) (caten (star(disj nt_CommentParser nt_whitespace))  (char ')') )) s in
+    ((List.fold_right (fun e acc -> Pair(e,acc)) exp Nil),s) and
   
+nt_SexpDottedList s=
+let (lparen,s) = (char '(')  s in
+  let(exp1,s) = (plus nt_Sexpr) s in 
+    let (dot,s) = make_enclosed (star (disj nt_CommentParser nt_whitespace)) (char '.') (star (disj nt_CommentParser nt_whitespace)) s in
+      let (exp,s)= nt_Sexpr s in
+        let(spaces,s) = star (disj nt_CommentParser nt_whitespace) s in
+          let (quote,s)= (char ')') s in
+            ((List.fold_right (fun e acc -> Pair(e,acc)) exp1 exp),s) and
+
+nt_VectorParser s=
+  let ((solmet,lquote),s)= caten (char '#') (char '(') s in
+    let ((sexplist,spaces),s) =caten (star nt_Sexpr)  (star (disj nt_CommentParser nt_whitespace))  s in
+      let (rquote,s)= (char ')') s in
+        (Vector sexplist,s) and
+
+
+nt_SexpListBracket s=
+let (exp,s) = (make_enclosed (char '[') (star nt_Sexpr) (caten (star (disj nt_CommentParser nt_whitespace))  (char ']') )) s in
+  ((List.fold_right (fun e acc -> Pair(e,acc)) exp Nil),s) and
+
+nt_SexpDottedListBracket s=
+let (exp1,s) = (make_enclosed (char '[') (plus nt_Sexpr) (caten (star (disj nt_CommentParser nt_whitespace))  (char '.') )) s in
+let ((exp,spaces),s)= caten nt_Sexpr  (star (disj nt_CommentParser nt_whitespace))  s in
+  let (quote,s)= (char ']') s in
+    ((List.fold_right (fun e acc -> Pair(e,acc)) exp1 exp),s) and
+
+nt_VectorParserBracket s=
+let ((solmet,lquote),s)= caten (char '#') (char '[') s in
+  let ((sexplist,spaces),s) =caten (star nt_Sexpr)  (star (disj nt_CommentParser nt_whitespace))  s in
+    let (rquote,s)= (char ']') s in
+      (Vector sexplist,s) and
+
+nt_Quoted s = 
+  let (quote,s)= (word "'") s in
+    let (exp,s)= nt_Sexpr s in
+      (Pair(Symbol("quote"),Pair(exp,Nil)),s) and
+
+
+nt_QQouted s=
+  let(quote,s)=(char '`') s in 
+    let(exp,s)= nt_Sexpr s in
+      (Pair(Symbol("quasiquote"),Pair (exp,Nil)),s) and
+
+nt_UnquotedSpliced s= 
+  let ((a,b),s)=caten (char ',') (char '@') s in
+    let (exp,s)= nt_Sexpr s in
+      (Pair(Symbol("unquote-splicing"),Pair(exp,Nil)),s) and
+
+nt_Unqouted s=
+  let(quote,s)=(char ',') s in 
+      let(exp,s)= nt_Sexpr s in
+        (Pair(Symbol("unquote"),Pair (exp,Nil)),s) and
+
+nt_SexprComment s =
+let ((solamet,semicolon),s) = caten (char '#') (char ';') s in
+  let(exptoremove,s) = nt_Sexpr s in 
+    let (exp,s) = nt_Sexpr s in (exp,s) and
+
+nt_DotsSexpList s=
+let (exp,s) = (make_enclosed nt_LeftParent (star nt_HelperEllipsis) (caten (star (disj nt_CommentParser nt_whitespace))  (maybe nt_RightParent) )) s in
+  ((List.fold_right (fun e acc -> Pair(e,acc)) exp Nil),s) and 
+
+nt_DotVectorParser s=
+let ((solmet,lquote),s)= caten (char '#') nt_LeftParent s in
+  let ((sexplist,spaces),s) =caten (star nt_HelperEllipsis)  (star (disj nt_CommentParser nt_whitespace))  s in
+    let (rquote,s)= (maybe nt_RightParent) s in
+      (Vector sexplist,s) and
+
+nt_DotSexpDottedList s=
+let (lparen,s) = nt_LeftParent  s in
+  let(exp1,s) = (plus nt_Sexpr) s in 
+    let (dot,s) = make_enclosed (star (disj nt_CommentParser nt_whitespace)) (char '.') (star (disj nt_CommentParser nt_whitespace)) s in
+      let (exp,s)= nt_HelperEllipsis s in
+        let(spaces,s) = star (disj nt_CommentParser nt_whitespace) s in
+          let (quote,s)= (maybe nt_RightParent) s in
+            ((List.fold_right (fun e acc -> Pair(e,acc)) exp1 exp),s) and
+
+nt_Ellipsis s =
+let (exp,s) = (make_enclosed (star (disj nt_CommentParser nt_whitespace))
+      (disj_list[ nt_DotSexpDottedList;nt_DotsSexpList; nt_DotVectorParser]) (caten(star (disj nt_CommentParser nt_whitespace)) nt_3dots)) s in
+(exp,s) and
+
+nt_HelperEllipsis s =
+  let (spaces,s) = star (disj nt_CommentParser nt_whitespace) s in
+    let (exp,s) = disj_list[ diff nt_Sexpr nt_Ellipsis; nt_DotSexpDottedList; nt_DotsSexpList; nt_DotVectorParser] s in (exp,s);;
+
+let nt_Ignore3Dots s = 
+  let(spaces,s) = star (disj nt_CommentParser nt_whitespace) s in
+    let (dots,s) = (word "...") s in
+      (dots,s);;
+let nt_remove3dots s=
+  let(a,b)= maybe(nt_Ignore3Dots) s in
+    nt_Sexpr b;;
+
+let read_sexpr string = let (exp,s) = (star nt_remove3dots) (string_to_list string) in 
+if (List.length exp > 1) then raise X_no_match 
+else if(List.length exp = 0)then raise X_no_match
+else List.hd exp;;
+
+let read_sexprs string = 
+  if(String.length string) == 0 then [] 
+  else  let(exp,s) = star(nt_remove3dots) (string_to_list string) in exp;;
 end;; (* struct Reader *)
+
diff --git a/readme.txt b/readme.txt
index e69de29..37fe6bf 100644
--- a/readme.txt
+++ b/readme.txt
@@ -0,0 +1,9 @@
+Ibrahim Awad ID: 318260585
+Nedal Ayoub ID: 318307998
+I (We) assert that the work we submitted is 100% our own. We have not received any
+part from any other student in the class, nor have we give parts of it for use to others.
+Nor have we used code from other sources: Courses taught previously at this university,
+courses taught at other universities, various bits of code found on the internet, etc.
+We realize that should our code be found to contain code from other sources, that a
+formal case shall be opened against us with va’adat mishma’at, in pursuit of disciplinary
+action.
diff --git a/semantic-analyser.ml b/semantic-analyser.ml
index dbd1601..cfe9c33 100644
--- a/semantic-analyser.ml
+++ b/semantic-analyser.ml
@@ -5,6 +5,7 @@
  *)
 
 #use "tag-parser.ml";;
+open Tag_Parser;;
 
 type var = 
   | VarFree of string
@@ -66,16 +67,209 @@ module type SEMANTICS = sig
 end;;
 
 module Semantics : SEMANTICS = struct
+let rec find_minor (x,stringlist)= 
+  match (String.equal x (List.hd stringlist)) with 
+  | true-> 0 
+  | false-> (1+ (find_minor (x,List.tl stringlist)));;
+  
+let rec make_var_lexical_addresses (x,stringlist,number)=
+  match stringlist with
+  | []-> VarFree(x)
+  | _->(
+    match List.mem x (List.hd stringlist) with
+    | true->( 
+      match number with
+      | -1-> VarParam(x,find_minor(x,List.hd stringlist))
+      | _-> VarBound(x,number,find_minor(x,List.hd stringlist))
+    )
+    | false-> make_var_lexical_addresses (x,List.tl stringlist,number+1)
+  );;
+  
+let rec make_lexical_addresses (expr ,stringlist)=
+  match expr with 
+  | Const(x)->Const'(x)
+  | If (expr1, expr2 ,expr3) -> If'( (make_lexical_addresses (expr1 ,stringlist)),(make_lexical_addresses (expr2 ,stringlist)),(make_lexical_addresses (expr3 ,stringlist)))
+  | Seq(exprlist)-> Seq' (List.map  make_lexical_addresses (List.map  (fun (x)->(x,stringlist)) exprlist ))
+  | Set(expr1,expr2)-> Set' ((make_lexical_addresses (expr1 ,stringlist)),(make_lexical_addresses (expr2 ,stringlist)))
+  | Def(expr1,expr2)-> Def' ((make_lexical_addresses (expr1 ,stringlist)),(make_lexical_addresses (expr2 ,stringlist)))
+  | Or(exprlist)-> Or' (List.map  make_lexical_addresses (List.map  (fun (x)->(x,stringlist)) exprlist ))
+  | Applic(expr1,exprlist)-> Applic' ((make_lexical_addresses (expr1 ,stringlist)),(List.map  make_lexical_addresses (List.map  (fun (x)->(x,stringlist)) exprlist )))
+  | LambdaSimple (stringlistparams,expr)-> LambdaSimple' (stringlistparams,make_lexical_addresses(expr,stringlistparams::stringlist))
+  | LambdaOpt(stringlistparams,s,expr)-> LambdaOpt' (stringlistparams,s, make_lexical_addresses(expr, (stringlistparams@ [s])::stringlist))
+  | Var(x)-> Var' (make_var_lexical_addresses (x,stringlist,-1));;
+
+let annotate_lexical_addresses e = make_lexical_addresses(e,[]);;
+
+let rec  make_applic_tp (e,inlambda)=
+  match e with  
+  | If' (expr1,expr2,expr3)->
+    (match inlambda with
+      | false-> If'(make_applic_tp(expr1,false),make_applic_tp (expr2,false),make_applic_tp (expr3,false))
+      | true-> If'(make_applic_tp(expr1,false),make_applic_tp (expr2,true),make_applic_tp (expr3,true))
+    )
+  | Seq'(exprlist)-> (
+      match inlambda with
+      | false-> Seq'(List.map make_applic_tp (List.map  (fun (x)->(x,false)) exprlist))
+      | true-> Seq' ((List.map make_applic_tp (List.map  (fun (x)->(x,false)) (List.rev (List.tl (List.rev exprlist)))))@ [make_applic_tp(List.hd (List.rev exprlist),true)])
+    )
+  | Set'(expr1,expr2)-> Set'(make_applic_tp(expr1,false),make_applic_tp(expr2,false))
+  | Def'(expr1,expr2)-> Def'(make_applic_tp(expr1,false),make_applic_tp(expr2,false))
+  | Or'(exprlist)->(
+      match inlambda with
+      | false-> Or'(List.map make_applic_tp (List.map  (fun (x)->(x,false)) exprlist))
+      | true-> Or' ((List.map make_applic_tp (List.map  (fun (x)->(x,false)) (List.rev (List.tl (List.rev exprlist)))))@ [make_applic_tp(List.hd (List.rev exprlist),true)])
+    )
+  | LambdaSimple'(parmslist,expr)->LambdaSimple'(parmslist,make_applic_tp(expr,true))
+  | LambdaOpt'(parmslist,optstring,expr)->LambdaOpt'(parmslist,optstring,make_applic_tp(expr,true))
+  | Applic' (expr,exprlist)-> 
+    (match inlambda with
+     | false-> Applic'(make_applic_tp (expr,false), (List.map make_applic_tp (List.map  (fun (x)->(x,false)) exprlist)))
+     | true-> ApplicTP'(make_applic_tp (expr,false), (List.map make_applic_tp (List.map  (fun (x)->(x,false)) exprlist)))
+    )
+  | _->e;;
+
+    
+    
+    ;;
+let  annotate_tail_calls e = make_applic_tp (e,false);;
+
+let check_get parm body =
+  let unique = 
+    let last = ref 0 in fun () -> incr last ; !last in
+  
+  let rec check_get_helper parm body numberlist  = 
+    match body with
+  | If' (expr1, expr2, expr3)-> (check_get_helper parm expr1 numberlist )@(check_get_helper parm expr2 numberlist )@(check_get_helper parm expr3 numberlist )
+  | Def' (expr1, expr2) -> (check_get_helper parm expr1 numberlist)@(check_get_helper parm expr2 numberlist)
+  | Seq' exprlist -> List.flatten  (List.map (fun(body)-> check_get_helper parm body numberlist)  exprlist)
+  | Set' (Var'(_),expr)->  (check_get_helper parm expr numberlist)
+  | BoxSet' (_, expr) -> check_get_helper parm expr numberlist
+  | Or' exprlist ->  List.flatten  (List.map (fun(body)-> check_get_helper parm body numberlist)  exprlist)
+  | Applic' (op, exprlist) | ApplicTP' (op, exprlist) -> (check_get_helper parm op numberlist)@ (List.map List.flatten  (List.map (fun(body)-> check_get_helper parm body numberlist)  exprlist))
+  | LambdaSimple' (parmlist,body1)-> if (List.mem parm parmlist  ) then ([]) else let num = unique() in(check_get_helper parm body1 (num::numberlist))
+  | LambdaOpt' (parmlist,opt,body1)-> if (List.mem parm (opt::parmlist)  ) then ([]) else let num = unique() in (check_get_helper parm body1 (num::numberlist))
+  | Var'(VarBound(name,minor,major))-> if (parm=name) then [numberlist] else ([])
+  | Var'(VarParam(name,minor))-> if (parm=name) then [numberlist] else ([])
+  | _->[] in
+  (check_get_helper parm body [0] )
+  ;;
+
+
+  let check_set parm body =
+    let unique = 
+      let last = ref 0 in fun () -> incr last ; !last in
+    
+    let rec check_set_helper parm body numberlist  = 
+      match body with
+    | If' (expr1, expr2, expr3)-> (check_set_helper parm expr1 numberlist )@(check_set_helper parm expr2 numberlist )@(check_set_helper parm expr3 numberlist )
+    | Def' (expr1, expr2) -> (check_set_helper parm expr1 numberlist)@(check_set_helper parm expr2 numberlist)
+    | Seq' exprlist -> List.flatten  (List.map (fun(body)-> check_set_helper parm body numberlist)  exprlist)
+    | Set' (Var'(VarBound(name,minor,major)),expr)-> if (parm=name) then ([numberlist]@ (check_set_helper parm expr numberlist)) else ((check_set_helper parm expr numberlist))
+    | Set' (Var'(VarParam (name,major)),expr)-> if (parm=name) then ([numberlist]@ (check_set_helper parm expr numberlist)) else ((check_set_helper parm expr numberlist))
+    | Set' (Var'(VarFree(x)),expr)-> (check_set_helper parm expr numberlist)
+    | BoxSet' (_, expr) -> check_set_helper parm expr numberlist
+    | Or' exprlist ->  List.flatten  (List.map (fun(body)-> check_set_helper parm body numberlist)  exprlist)
+    | Applic' (op, exprlist) | ApplicTP' (op, exprlist) -> (check_set_helper parm op numberlist)@ (List.map List.flatten  (List.map (fun(body)-> check_set_helper parm body numberlist)  exprlist))
+    | LambdaSimple' (parmlist,body1)-> if (List.mem parm parmlist  ) then ([]) else let num = unique() in(check_set_helper parm body1 (num::numberlist))
+    | LambdaOpt' (parmlist,opt,body1)-> if (List.mem parm (opt::parmlist)  ) then ([]) else let num = unique() in (check_set_helper parm body1 (num::numberlist))
+    | Var'(VarBound(name,minor,major))-> if (parm=name) then [] else ([])
+    | Var'(VarParam(name,minor))-> if (parm=name) then [] else ([])
+    | _->[] in
+    
+    (check_set_helper parm body [0] )
+    ;;
 
-let annotate_lexical_addresses e = raise X_not_yet_implemented;;
+ let check_combination (x,y)=
+  let lastone =(List.hd x != List.hd y)  in
+  let rec common_ancestor (x,y)=
+   if (y=[] || x=[]) then true  else (
+     match List.hd x = List.hd y with
+     | true->  false
+     | false ->common_ancestor (List.tl x,List.tl y)
+   ) in
+  ( lastone && common_ancestor (List.tl (List.rev x),List.tl (List.rev y)) )
+  ;;
 
-let annotate_tail_calls e = raise X_not_yet_implemented;;
+let check_if_should_box_parm (parm ,body)=
+  let setlist= List.filter (fun(x)->x!=[]) (check_set parm body)  in
+    let getlist= List.filter (fun(x)->x!=[]) (check_get parm body)  in
+      let combinationlist= List.concat (List.map (fun(x)->List.map (fun(y)->(x,y)) getlist) setlist) in
+        if (ormap check_combination combinationlist) then parm else "";;
 
-let box_set e = raise X_not_yet_implemented;;
 
-let run_semantics expr =
-  box_set
+let checklambdaparms parmslist body=
+  let list1= List.map check_if_should_box_parm (List.map (fun(x)-> (x,body)) parmslist) in
+    let list2= List.filter (fun(x)->x!="") list1 in
+      list2;; 
+
+let rec parmstoset parmlisttobox parmListwithminor =
+  if (parmListwithminor = []) then [] 
+    else (
+      let (a,b)=List.hd parmListwithminor in
+        if(List.mem a parmlisttobox ) then ((a,b)::(parmstoset parmlisttobox (List.tl parmListwithminor ))) 
+          else ((parmstoset parmlisttobox (List.tl parmListwithminor )))
+    )
+  ;;
+
+let makeindexlist length=
+  let rec makeindex number=
+    if(number=length) then [] else (number::makeindex(number+1)) in
+  makeindex 0;;
+
+let makebodyprefix parmList  newparmstobox =
+  let parmListwithminor= List.map2 (fun x y->(x,y)) parmList (makeindexlist (List.length parmList)) in
+      let  parmswithminortoset= parmstoset newparmstobox parmListwithminor in
+        List.map (fun (a,b)->Set' (Var'(VarParam(a,b)),Box'(VarParam(a,b)))) parmswithminortoset
+
+;;
+
+let rec box_set_helper (e,stringlist)=
+  match e with
+  | Const' _  | Box' _ | BoxGet' _ | Var'(VarFree(_)) -> e
+  | Var' (VarBound(name,minor,major))->
+    if (List.mem  name stringlist) then ( BoxGet'(VarBound(name,minor,major))) else (e)
+  | Var'(VarParam(name,x))->
+    if (List.mem  name stringlist) then ( BoxGet'(VarParam(name,x))) else (e)
+  | BoxSet' (var, expr) -> BoxSet' (var, box_set_helper (expr ,stringlist))
+  | Def'(expr1,expr2)-> Def'(box_set_helper (expr1 ,stringlist),box_set_helper (expr2 ,stringlist))
+  | If' (expr1,expr2,expr3)-> If' (box_set_helper (expr1 ,stringlist),box_set_helper (expr2 ,stringlist),box_set_helper (expr3 ,stringlist))
+  | Seq'(exprlist)-> Seq'(List.map box_set_helper (List.map  (fun(x)->(x,stringlist)) exprlist ) )
+  | Set'(Var'(VarBound(name,minor,major)),expr2)-> 
+    if (List.mem  name stringlist) then BoxSet'(VarBound(name,minor,major),box_set_helper (expr2,stringlist)) else (Set'(Var'(VarBound(name,minor,major)),box_set_helper (expr2,stringlist)))
+  | Set'(Var'(VarParam(name,minor)),expr2)->
+    if (List.mem  name stringlist) then BoxSet'(VarParam(name,minor),box_set_helper (expr2,stringlist)) else (Set'(Var'(VarParam(name,minor)),box_set_helper (expr2,stringlist)))
+  | Set'(Var'(VarFree(name)),expr2)-> Set'(Var'(VarFree(name)),box_set_helper (expr2,stringlist))
+  | Or'(exprlist)-> Or' (List.map box_set_helper (List.map  (fun(x)->(x,stringlist)) exprlist ) )
+  | Applic'(expr1,exprlist) -> Applic'(box_set_helper (expr1,stringlist),(List.map box_set_helper (List.map  (fun(x)->(x,stringlist)) exprlist ) ))
+  | ApplicTP'(expr1,exprlist)-> ApplicTP'(box_set_helper (expr1,stringlist),(List.map box_set_helper (List.map  (fun(x)->(x,stringlist)) exprlist ) ))
+  | LambdaSimple' (parmlist,body)-> 
+    (let new_string_list= List.filter (fun(x)-> not (List.mem x parmlist)) stringlist in
+      let newparmstobox= checklambdaparms parmlist body in
+        let prefixtoadd= makebodyprefix parmlist  newparmstobox in
+          let body1= box_set_helper (body ,(newparmstobox@new_string_list)) in
+            (match prefixtoadd@[body1] with
+              | []-> LambdaSimple'(parmlist,Const' Void)
+              | x::[]->LambdaSimple'(parmlist,x)
+              | other->LambdaSimple'(parmlist,Seq' other))
+    )
+  | LambdaOpt' (parmlist,opt,body)->
+    (let new_string_list= List.filter (fun(x)-> not (List.mem x parmlist)) stringlist in
+      let newparmstobox= checklambdaparms (opt::parmlist) body in
+        let prefixtoadd= makebodyprefix (parmlist@[opt])  newparmstobox in
+          let body1= box_set_helper (body ,(newparmstobox@new_string_list)) in
+            (match prefixtoadd@[body1] with
+              | []-> LambdaOpt'(parmlist,opt,Const' Void)
+              | x::[]->LambdaOpt'(parmlist,opt,x)
+              | other->LambdaOpt'(parmlist,opt,Seq' other)
+            )
+    )
+  | _-> raise X_this_should_not_happen
+  ;;
+
+let box_set e = box_set_helper (e,[]);;
+
+let run_semantics expr = 
+    box_set  
     (annotate_tail_calls
        (annotate_lexical_addresses expr));;
-  
 end;; (* struct Semantics *)
diff --git a/tag-parser.ml b/tag-parser.ml
index 619497a..dd3abe2 100644
--- a/tag-parser.ml
+++ b/tag-parser.ml
@@ -4,8 +4,10 @@
  * Programmer: Mayer Goldberg, 2018
  *)
 
-#use "reader.ml";;
 
+
+#use "reader.ml";;
+open PC;;
 type constant =
   | Sexpr of sexpr
   | Void
@@ -47,11 +49,12 @@ let rec expr_eq e1 e2 =
        (List.for_all2 expr_eq args1 args2)
   | _ -> false;;
 	
-                       
+
+
 exception X_syntax_error;;
 
 module type TAG_PARSER = sig
-  val tag_parse_expression : sexpr -> expr
+  val tag_parse_expression : sexpr -> expr 
   val tag_parse_expressions : sexpr list -> expr list
 end;; (* signature TAG_PARSER *)
 
@@ -64,10 +67,299 @@ let reserved_word_list =
    "unquote-splicing"];;  
 
 (* work on the tag parser starts here *)
+let nt_none_syntax _ = raise X_syntax_error;;
+let disj_syntax nt1 nt2 =
+  fun s ->
+  try (nt1 s)
+  with X_syntax_error -> (nt2 s);;
+
+let disj_list_syntax nts = List.fold_right disj_syntax nts nt_none_syntax;;
+
+let rec make_s sexprlist= 
+  match sexprlist with
+  | []->Nil
+  | _-> Pair(List.hd sexprlist,make_s (List.tl sexprlist));;
+ 
+
+let rec get_Sexpr_from_quasiquote sexpr=
+match sexpr with
+| Pair(Symbol "unquote",Pair(sexpr,Nil))-> sexpr
+| Pair(Symbol "unquote-splicing",Pair(sexpr,Nil))-> raise X_syntax_error
+| Nil-> (Pair((Symbol("quote")), (Pair(sexpr, Nil))))
+| Symbol _ -> (Pair((Symbol("quote")), (Pair(sexpr, Nil))))
+| Vector(sexpr)->  let vectorList = ( (List.map (fun expr1 -> get_Sexpr_from_quasiquote expr1) sexpr )) in
+  (Pair((Symbol("vector")), (make_s vectorList))) 
+| Pair((Pair((Symbol("unquote-splicing")), (Pair(firstsexp, Nil)))),secoundsexp)->let secoundsexp = get_Sexpr_from_quasiquote secoundsexp in
+  (Pair((Symbol("append")), (Pair(firstsexp, (Pair(secoundsexp, Nil))))))
+| Pair(firstsexp,(Pair((Symbol("unquote-splicing")), (Pair(secoundsexp, Nil)))))->let firstsexp=get_Sexpr_from_quasiquote firstsexp in
+  (Pair((Symbol("cons")),
+  (Pair(firstsexp, (Pair(secoundsexp, Nil))))))
+| Pair(firstsexp,secoundsexp)->
+  let firstsexp = get_Sexpr_from_quasiquote firstsexp in
+    let secoundsexp = get_Sexpr_from_quasiquote secoundsexp in
+      (Pair((Symbol("cons")), (Pair(firstsexp, (Pair(secoundsexp, Nil))))))
+| _->sexpr;;   
+
+
+
+let rec cond_expand sexpr=
+  match sexpr with
+  | Nil->Nil
+  | Pair(sexpr1,rest)-> 
+    (match sexpr1 with 
+    | Pair(Symbol "else",rest1)-> (
+      match rest with 
+      | Nil->Pair(Symbol "begin",rest1)
+      | _-> raise X_syntax_error
+      )
+    | Pair(exp,Pair(Symbol "=>", rest1))->( 
+      match rest with
+      | Nil->  Pair(Symbol "let",Pair(Pair(Pair(Symbol "value",Pair(exp,Nil)),Pair(Pair(Symbol "f",Pair(Pair(Symbol "lambda",Pair(Nil,rest1)),Nil)),Nil)),Pair(Pair (Symbol "if",Pair (Symbol "value", Pair (Pair(Pair(Symbol "f",Nil),Pair(Symbol "value",Nil)),Nil))),Nil)))
+      | _-> Pair(Symbol "let",Pair(Pair(Pair(Symbol "value",Pair(exp,Nil)),Pair(Pair(Symbol "f",Pair(Pair(Symbol "lambda",Pair(Nil,rest1)),Nil)),Pair(Pair(Symbol "rest",Pair(Symbol "lambda",Pair(Nil,Pair(cond_expand rest,Nil)))),Nil))),Pair(Pair (Symbol "if",Pair (Symbol "value", Pair (Pair(Pair(Symbol "f",Nil),Pair(Symbol "value",Nil)), Pair (Pair(Symbol "rest",Nil), Nil)))),Nil)))
+    )
+      | Pair(test,rest1)-> (
+        match rest with 
+        | Nil-> Pair (Symbol "if",Pair (test, Pair (Pair(Symbol "begin",rest1), Nil)))
+        | _-> Pair (Symbol "if",Pair (test, Pair (Pair(Symbol "begin",rest1), Pair ((cond_expand rest), Nil))))
+      )
+    | _->raise X_syntax_error
+    )
+  | _->raise X_syntax_error
+  
+
+let rec  tag_parse_expression sexpr =  disj_list_syntax [cond_tag_parser;mit_define_tag_parser;quote_tag_parser;letrec_tag_parser;and_tag_parser;let_star_tag_parser;let_expansion_tag_parser;begin_tag_parser;or_tag_parser;one_element_tag_parser;if_tag_parser;set_tag_parser;lambda_tag_parser;define_tag_parser;applic_tag_parser]  sexpr and
+
+or_tag_parser sexpr=
+  match sexpr with 
+  |Pair(Symbol "or",sexplist)->(match sexplist with
+    | Nil->Const(Sexpr(Bool(false )))
+    |_->(let a = (pair_to_exprlist sexplist) in 
+      match List.length a with
+      | 1-> List.hd a
+      | _-> Or a
+       )
+    )
+  | _->raise X_syntax_error and
+
+set_tag_parser sexpr=
+  match sexpr with 
+  | Pair(Symbol "set!",Pair(Symbol(name),Pair(sexpr1,Nil)))->Set(tag_parse_expression (Symbol(name)),tag_parse_expression sexpr1)
+  | _->raise X_syntax_error and
+
+define_tag_parser sexpr=
+  match sexpr with 
+  |Pair(Symbol "define",Pair(Symbol(name),Pair(sexpr1,Nil)))->Def(tag_parse_expression (Symbol(name)) ,tag_parse_expression sexpr1)
+  | _->raise X_syntax_error and
+
+begin_tag_parser sexpr=
+  match sexpr with
+  | Pair(Symbol "begin",sexpr)->(
+    match sexpr with 
+    | Nil->Const(Void)
+    | Pair(sexp1,sexp2)-> (match sexp2 with
+      |Nil-> let a=pair_to_exprlist (Pair(sexp1,sexp2)) in (match (List.length a) with 
+              | 1-> List.hd a
+              | _-> Seq a
+              )
+      |_->Seq (pair_to_exprlist (Pair(sexp1,sexp2)) ))
+    |_-> raise X_syntax_error 
+  )
+
+  |_-> raise X_syntax_error and
+
+applic_tag_parser sexpr=
+  match sexpr with
+  | Pair(Symbol(x),rest)->(let exprlist=(pair_to_exprlist rest) in
+    match List.mem x reserved_word_list with
+    | true-> raise X_syntax_error
+    | false-> Applic(Var(x), exprlist)
+    )
+  | Pair(Pair(sexp1,sexp2),Pair(sexp3,sexp4))-> (let exprlist=(pair_to_exprlist (Pair(sexp3,sexp4))) in
+    match check_applic_if_lambda (Pair(sexp1,sexp2)) with
+    | false ->(let parsed_exp=tag_parse_expression (Pair(sexp1,sexp2)) in Applic(parsed_exp,exprlist))
+    | true -> match sexp2 with 
+              |Pair(args,body)->  (match is_proper args with
+                            |false->let parsed_exp1 = tag_parse_expression (Pair(sexp1,sexp2)) in Applic(parsed_exp1,exprlist)
+                            | true-> let a =get_string_if_applic_lambda (Pair(sexp1,sexp2)) in (match ((List.length a)=(List.length exprlist)) with
+                                                                                                | false -> raise X_syntax_error
+                                                                                                | true -> let parsed_exp=tag_parse_expression (Pair(sexp1,sexp2)) in Applic(parsed_exp,exprlist)
+                          ))
+              | _->raise X_syntax_error
+  )
+  | Pair(Pair(sexpr1,sexpr2),Nil)-> (let exprlist= (pair_to_exprlist (Pair(Pair(sexpr1,sexpr2),Nil)))  in
+    match List.hd exprlist with
+    | Const(Sexpr(Symbol(s)))-> (match (List.mem s reserved_word_list  )with
+      | true-> raise X_syntax_error
+      | false-> Applic(Var(s),List.tl exprlist))
+    |_-> Applic(List.hd exprlist,[]))
+  | Pair(sexp,rest)->
+    (match rest with 
+    | Nil->(try Applic(tag_parse_expression sexp,[]) with 
+            | X_syntax_error->raise X_syntax_error
+          )
+    | _-> ( try Applic(tag_parse_expression sexp,pair_to_exprlist rest) with 
+            | X_syntax_error->raise X_syntax_error 
+          )
+    )
+  | _->raise  X_syntax_error and
+
+
+check_applic_if_lambda sexpr=
+  match sexpr with 
+  | Pair(Symbol "lambda", Pair(_arglist, _body))->  true
+  | _->false and
+
+get_string_if_applic_lambda sexpr =
+  match sexpr with
+  |Pair(Symbol "lambda", Pair(_arglist, _body))-> lambda_args_to_string_list _arglist
+  | _->[]  and 
+
+if_tag_parser sexpr=
+  match sexpr with
+  | Pair (Symbol "if",Pair (_test, Pair (_then, Pair (_else, Nil))))-> If ((tag_parse_expression _test), (tag_parse_expression _then ) ,(tag_parse_expression _else ))
+  | Pair (Symbol "if", Pair (_test, Pair ( _then, Nil))) -> If ((tag_parse_expression _test), (tag_parse_expression _then ) ,(Const(Void)))
+  | _-> raise X_syntax_error  and 
+  
+one_element_tag_parser sexpr= 
+  match sexpr with
+  | Number(x)->Const(Sexpr(Number(x)))
+  | Bool(x)->Const(Sexpr(Bool(x)))
+  | Char(x)->Const(Sexpr(Char(x)))
+  | String(x)->Const(Sexpr(String(x)))
+  | Symbol(x)-> (match List.mem x reserved_word_list with
+                |false->Var(x)
+                |true->raise X_syntax_error)
+  | Nil->Const(Sexpr(Nil))
+  | _->raise X_syntax_error   and
+
+lambda_tag_parser sexpr=
+  match sexpr with
+  | Pair(Symbol "lambda", Pair(_arglist, _body))-> 
+  (match _body with 
+  |Nil->raise X_syntax_error
+  |_->let args=lambda_args_to_string_list _arglist in
+    (match(lambda_args_check args) with
+    | false->
+      (match (is_proper _arglist) with
+        | true-> LambdaSimple ((lambda_args_to_string_list _arglist), single_or_seq( pair_to_exprlist _body))
+        | false->let (a,b)= improper_stringList (lambda_args_to_string_list _arglist) in LambdaOpt (a,b, single_or_seq( pair_to_exprlist _body))
+      )
+    |_->raise X_syntax_error 
+    ))
+  | _-> raise X_syntax_error    and 
+
+pair_to_exprlist sexpr= 
+  match sexpr with
+  | Nil->[]
+  | Pair(sexp1,rest)-> (tag_parse_expression sexp1)::(pair_to_exprlist rest)
+  |_->raise X_syntax_error   and
+
+ 
+improper_stringList stringlist=
+  ((List.rev (List.tl (List.rev stringlist))),List.hd (List.rev stringlist) ) and
+
+single_or_seq list1=
+  match List.length list1 with 
+  | 1-> List.hd list1
+  | 0-> Const(Void)
+  | _-> Seq list1 and
+
+is_proper sexpr=
+  match sexpr with
+  | Nil->true
+  | Pair(_,rest)->is_proper rest
+  | Symbol(x) ->false
+  | _ ->raise X_syntax_error and
+
+lambda_args_to_string_list sexpr=
+  match sexpr with
+  | Nil->[]
+  | Symbol(x)->[x]
+  | Pair(Symbol(x),rest)->x:: (lambda_args_to_string_list rest)
+  | _->raise X_syntax_error and
+
+lambda_args_check stringlist=
+  match stringlist with
+  | []->false
+  | _-> (
+    match List.mem  (List.hd stringlist) (List.tl stringlist) with
+    |true->raise X_syntax_error
+    |false->lambda_args_check (List.tl stringlist)
+  ) and
+
+ let_expansion_tag_parser sexp= 
+  match sexp with 
+  | Pair(Symbol "let",Pair(Nil,body))-> Applic ( LambdaSimple([],single_or_seq(pair_to_exprlist body)),[])
+  | Pair(Symbol "let",Pair(args,body))-> let (definitionsnames,exprlist)= definitions_tag_parser args in 
+    (match (((List.length definitionsnames) = (List.length exprlist)) && (not(lambda_args_check definitionsnames)) ) with
+      | true->Applic ( LambdaSimple(definitionsnames,single_or_seq(pair_to_exprlist body)), exprlist)
+      | false-> raise X_syntax_error)
+  |  _->raise X_syntax_error and
+
+ 
+let_star_tag_parser sexp=
+  match sexp with 
+  | Pair(Symbol "let*",Pair(Nil,body))-> tag_parse_expression(Pair(Symbol "let",Pair(Nil,body)))
+  | Pair(Symbol "let*",Pair(args,body))-> 
+    (match args with 
+    | Pair(Pair(Symbol(x),s1),Nil)->  tag_parse_expression  (Pair(Symbol "let",Pair(args,body)))
+    | Pair(Pair(Symbol(x),s1),rest)-> tag_parse_expression (Pair(Symbol "let",Pair(Pair(Pair(Symbol(x), s1),Nil),Pair(Pair(Symbol "let*",Pair(rest,body)),Nil))))
+    |_->raise X_syntax_error  
+    ) 
+  
+  |_-> raise X_syntax_error and 
+
+mit_define_tag_parser sexpr=
+  match sexpr with
+  | Pair(Symbol "define",Pair(Pair(var,arglist),exp))-> tag_parse_expression( Pair(Symbol "define",Pair(var,Pair(Pair(Symbol "lambda", Pair(arglist, exp)),Nil))) )
+  |_->raise X_syntax_error and
+ 
+
+and_tag_parser sexp=
+  match sexp with
+  | Pair(Symbol "and",Nil)-> Const(Sexpr(Bool(true)))
+  | Pair(Symbol "and",Pair(sexp1,rest))-> let a=pair_to_exprlist (Pair(sexp1,rest)) in (match List.length a with
+    |1-> List.hd a 
+    |_-> tag_parse_expression (Pair (Symbol "if",Pair (sexp1, Pair (Pair(Symbol "and",rest), Pair (Bool false , Nil))))) ) 
+  | _->raise X_syntax_error and
+
+
+letrec_tag_parser sexp=
+  match sexp with 
+  | Pair(Symbol "letrec",Pair(args ,body1))-> let (args,body2)=letrec_tuple args body1 in tag_parse_expression (Pair(Symbol "let",Pair(args,body2)))
+  | _-> raise X_syntax_error and
 
-let tag_parse_expression sexpr = raise X_not_yet_implemented;;
+  (* (Pair(Symbol "letrec", Pair(Nil, Pair(Symbol "g", Pair(Symbol "f", Nil)))))  *)
+letrec_tuple sexp body1 =
+  match sexp with
+  | Nil->(Nil,body1)
+  | Pair(sexp1,sexp2)->(
+    match sexp1 with 
+    | Pair(Symbol(x),s1)->let (a,b)=letrec_tuple sexp2 body1 in ((Pair(Pair(Symbol(x),Pair(Symbol "quote",Pair(Symbol "whatever",Nil))),a)), (Pair(Pair(Symbol "set!",Pair(Symbol(x),s1)),b)))
+    | _->raise X_syntax_error
+  )
+  | _->raise X_syntax_error and
 
-let tag_parse_expressions sexpr = raise X_not_yet_implemented;;
+cond_tag_parser sexpr =
+  match sexpr with 
+  | Pair(Symbol "cond",ribs)-> tag_parse_expression (cond_expand ribs)
+  | _->raise X_syntax_error and
 
+quote_tag_parser sexpr=
+  match sexpr with
+  | Pair (Symbol "quote", Pair(sexp,Nil))  -> Const(Sexpr(sexp)) 
+  | Pair (Symbol "unquote", Pair(sexp,Nil)) -> raise X_syntax_error 
+  | Pair (Symbol "quasiquote", Pair(sexp,Nil)) -> tag_parse_expression (get_Sexpr_from_quasiquote sexp)
+  | _->raise X_syntax_error and
   
-end;; (* struct Tag_Parser *)
+definitions_tag_parser sexp=
+  match sexp with
+  | Nil-> ([],[])
+  | Pair(sexp1,sexp2)->(match sexp1 with 
+    | Pair (Symbol(x),Pair(s1,Nil))->let (a,b)=definitions_tag_parser sexp2 in (x::a, (tag_parse_expression s1)::b)
+    | Pair(Symbol(x),s1)-> let (a,b)=definitions_tag_parser sexp2 in (x::a, (tag_parse_expression s1)::b)
+    | _-> raise X_syntax_error )
+  | _-> raise X_syntax_error 
+;;
+let tag_parse_expressions sexpr = List.map tag_parse_expression sexpr;;
+end;;
